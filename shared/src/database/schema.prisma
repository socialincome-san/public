generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
  binaryTargets   = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  male
  female
  other
  private
}

enum WhatsAppActivationStatus {
  disabled
  pending
  verified
}

enum PaymentEventType {
  stripe
  bank_transfer
}

enum ContributionStatus {
  failed
  pending
  succeeded
}

enum RecipientStatus {
  active
  suspended
  waitlisted
  former
}

enum PayoutStatus {
  created
  paid
  confirmed
  contested
  failed
  other
}

enum SurveyStatus {
  new
  sent
  scheduled
  in_progress
  completed
  missed
}

enum SurveyQuestionnaire {
  onboarding
  checkin
  offboarding
  offboarded_checkin
}

enum ProgramPermission {
  admin
  audit
}

enum OrganizationPermission {
  admin
  audit
}

enum ContributorReferralSource {
  family_and_friends
  work
  social_media
  media
  presentation
  other
}

enum ExpenseType {
  account_fees
  administrative
  delivery_fees
  donation_fees
  exchange_rate_loss
  fundraising_advertising
  staff
}

model UserAccount {
  id String @id @default(cuid()) @map("id")
  /*
    We don't store email or phone here, as we use Firebase Authentication for that.

    Migration considerations:
    For contributors, this should be easy. We have an auth_user_id field for every contributor, so we can just link a
    user account to every contributor.
    For recipients, we won't be able to create UserAccount entries. What we will need is a login endpoint that is very
    similar to what we already have in functions/src/functions/webhooks/auth/twilio-verify.ts. If a recipient tries to
    log in, we do the phone verification, create/get the Firebase Auth user, and then we check wheter a UserAccount
    already exists in this table. If not, we create the UserAccount instance dynamically if there is a recipient with
    that phone number (recipient.paymentInformation.phone.number). (We currently do something similar already, but in
    the app. See recipients_app/lib/data/datasource/remote/user_remote_data_source.dart line 26-36).
    If there is no UserAccount entry and no recipient with that phone number, we throw an error (no such user).

    One thing to consider here, is that we will have to make sure that the phone numbers and email addresses from the
    Firebase Auth users stay in sync with the phone numbers and email addresses in our Contact table. This is not a big
    issue, but we need to be aware of it when we implement profile update features.
  */

  firebaseAuthUserId String @unique @map("firebase_auth_user_id")

  contributor          Contributor?
  recipient            Recipient?
  OrganizationAccesses OrganizationAccess[]
  ProgramAccess        ProgramAccess[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("user")
}

model Contributor {
  id                 String                    @id @default(cuid()) @map("id")
  userAccountId      String                    @unique @map("user_account_id")
  userAccount        UserAccount               @relation(fields: [userAccountId], references: [id])
  contactId          String                    @unique @map("contact_profile_id")
  contact            Contact                   @relation(fields: [contactId], references: [id])
  referral           ContributorReferralSource @map("referral")
  paymentReferenceId String?                   @map("payment_reference_id")
  stripeCustomerId   String?                   @map("stripe_customer_id")
  institution        Boolean                   @default(false) @map("institution")

  contributions        Contribution[]
  donationCertificates DonationCertificate[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("contributor")
}

model Contribution {
  id            String             @id @default(cuid()) @map("id")
  amount        Decimal            @map("amount") @db.Decimal(10, 2)
  currency      String             @map("currency")
  amountChf     Decimal            @map("amount_chf") @db.Decimal(10, 2)
  feesChf       Decimal            @map("fees_chf") @db.Decimal(10, 2)
  contributorId String             @map("contributor_id")
  contributor   Contributor        @relation(fields: [contributorId], references: [id])
  status        ContributionStatus @map("status")
  campaignId    String             @map("campaign_id")
  campaign      Campaign           @relation(fields: [campaignId], references: [id])
  paymentEvent  PaymentEvent?

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("contribution")
}

model PaymentEvent {
  id             String           @id @default(cuid()) @map("id")
  contributionId String           @unique @map("contribution_id")
  contribution   Contribution     @relation(fields: [contributionId], references: [id])
  type           PaymentEventType @map("type")
  transactionId  String?          @map("transaction_id")
  metadata       Json?            @map("metadata")

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("payment_event")
}

model DonationCertificate {
  id            String      @id @default(cuid()) @map("id")
  contributorId String      @map("contributor_id")
  contributor   Contributor @relation(fields: [contributorId], references: [id])
  year          Int         @map("year")
  storagePath   String      @map("storage_path")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([contributorId, year])
  @@map("donation_certificate")
}

model Recipient {
  id                   String              @id @default(cuid()) @map("id")
  userAccountId        String              @unique @map("user_account_id")
  userAccount          UserAccount         @relation(fields: [userAccountId], references: [id])
  contactId            String              @unique @map("contact_profile_id")
  contact              Contact             @relation(fields: [contactId], references: [id])
  startDate            DateTime?           @map("start_date") @db.Timestamptz(3)
  status               RecipientStatus     @map("status")
  successorName        String?             @map("successor_name")
  termsAccepted        Boolean             @default(false) @map("terms_accepted")
  paymentInformationId String?             @map("payment_information_id") // nullable because payment info might not be available yet on creation
  paymentInformation   PaymentInformation? @relation(fields: [paymentInformationId], references: [id])
  programId            String              @map("program_id")
  program              Program             @relation(fields: [programId], references: [id])
  localPartnerId       String              @map("local_partner_id")
  localPartner         LocalPartner        @relation(fields: [localPartnerId], references: [id])
  payouts              Payout[]
  surveys              Survey[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("recipient")
}

model Payout {
  id          String       @id @default(cuid()) @map("id")
  amount      Decimal      @map("amount") @db.Decimal(10, 2)
  amountChf   Decimal?     @map("amount_chf")
  currency    String       @map("currency")
  paymentAt   DateTime     @map("payment_at") @db.Timestamptz(3)
  status      PayoutStatus @map("status")
  phoneNumber String?      @map("phone_number")
  comments    String?      @map("comments")
  message     String?      @map("message")
  recipientId String       @map("recipient_id")
  recipient   Recipient    @relation(fields: [recipientId], references: [id])

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("payout")
}

model Survey {
  id            String              @id @default(cuid()) @map("id")
  recipientId   String              @map("recipient_id")
  recipient     Recipient           @relation(fields: [recipientId], references: [id])
  questionnaire SurveyQuestionnaire @map("questionnaire")
  language      String              @map("language")
  dueAt         DateTime            @map("due_at")
  sentAt        DateTime?           @map("sent_at")
  completedAt   DateTime?           @map("completed_at")
  status        SurveyStatus        @map("status")
  comments      String?             @map("comments")
  data          Json                @map("data")
  accessEmail   String              @map("access_email")
  accessPw      String              @map("access_pw")
  accessToken   String              @map("access_token")

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("survey")
}

model LocalPartner {
  id         String      @id @default(cuid()) @map("id")
  contactId  String      @unique @map("contact_profile_id")
  contact    Contact     @relation(fields: [contactId], references: [id])
  recipients Recipient[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("local_partner")
}

model OrganizationAccess {
  id             String                   @id @default(cuid())
  userAccountId  String
  userAccount    UserAccount              @relation(fields: [userAccountId], references: [id])
  organizationId String
  organization   Organization             @relation(fields: [organizationId], references: [id])
  permissions    OrganizationPermission[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@unique([userAccountId, organizationId])
  @@map("organization_access")
}

model ProgramAccess {
  id            String      @id @default(cuid())
  userAccountId String
  userAccount   UserAccount @relation(fields: [userAccountId], references: [id])
  programId     String
  program       Program     @relation(fields: [programId], references: [id])

  permissions ProgramPermission[]

  @@unique([userAccountId, programId])
  @@map("program_access")
}

model Organization {
  id               String               @id @default(cuid()) @map("id")
  name             String               @unique @map("name")
  accesses         OrganizationAccess[]
  ownedPrograms    Program[]            @relation("ProgramOwner")
  operatedPrograms Program[]            @relation("ProgramOperator")
  expenses         Expense[]
  campaigns        Campaign[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("organization")
}

model Program {
  id                     String          @id @default(cuid()) @map("id")
  name                   String          @unique @map("name")
  totalPayments          Int             @map("total_payments")
  payoutAmount           Decimal         @map("payout_amount") @db.Decimal(10, 2)
  payoutCurrency         String          @map("payout_currency")
  payoutInterval         Int             @map("payout_interval")
  country                String          @default("Sierra Leone") @map("country")
  ownerOrganizationId    String          @map("owner_organization_id")
  owner                  Organization    @relation("ProgramOwner", fields: [ownerOrganizationId], references: [id])
  operatorOrganizationId String          @map("operator_organization_id")
  operator               Organization    @relation("ProgramOperator", fields: [operatorOrganizationId], references: [id])
  campaigns              Campaign[]
  recipients             Recipient[]
  accesses               ProgramAccess[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("program")
}

model Campaign {
  id                     String         @id @default(cuid()) @map("id")
  title                  String         @map("title")
  description            String         @map("description")
  secondDescriptionTitle String?        @map("second_description_title")
  secondDescription      String?        @map("second_description")
  thirdDescriptionTitle  String?        @map("third_description_title")
  thirdDescription       String?        @map("third_description")
  linkWebsite            String?        @map("link_website")
  linkInstagram          String?        @map("link_instagram")
  linkTiktok             String?        @map("link_tiktok")
  linkFacebook           String?        @map("link_facebook")
  linkX                  String?        @map("link_x")
  goal                   Decimal?       @map("goal") @db.Decimal(10, 2)
  currency               String         @map("currency")
  additionalAmountChf    Decimal?       @map("additional_amount_chf") @db.Decimal(10, 2)
  endDate                DateTime       @map("end_date")
  isActive               Boolean        @default(false) @map("is_active")
  public                 Boolean?       @map("public")
  featured               Boolean?       @map("featured")
  slug                   String?        @map("slug")
  metadataDescription    String?        @map("metadata_description")
  metadataOgImage        String?        @map("metadata_og_image")
  metadataTwitterImage   String?        @map("metadata_twitter_image")
  creatorName            String?        @map("creator_name")
  creatorEmail           String?        @map("creator_email")
  programId              String?        @map("program_id")
  program                Program?       @relation(fields: [programId], references: [id])
  organizationId         String         @map("organization_id")
  organization           Organization   @relation(fields: [organizationId], references: [id])
  contributions          Contribution[]

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("campaign")
}

model Expense {
  id             String       @id @default(cuid()) @map("id")
  organizationId String       @map("organization_id")
  organization   Organization @relation(fields: [organizationId], references: [id])
  type           ExpenseType  @map("type")
  year           Int          @map("year")
  amountChf      Decimal      @map("amount_chf") @db.Decimal(10, 2)

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("expense")
}

model Address {
  id      String    @id @default(cuid()) @map("id")
  street  String    @map("street")
  number  String    @map("number")
  city    String    @map("city")
  zip     String    @map("zip")
  country String    @map("country")
  contact Contact[]

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("address")
}

enum PaymentProvider {
  orange_money
}

model PaymentInformation {
  id        String          @id @default(cuid()) @map("id")
  provider  PaymentProvider @map("provider")
  code      String          @unique @map("code") // om_uid in case of Orange Money
  phoneId   String?         @map("phone_id")
  phone     Phone?          @relation(fields: [phoneId], references: [id])
  Recipient Recipient[]

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("payment_information")
}

model Contact {
  id          String    @id @default(cuid()) @map("id")
  firstName   String    @map("first_name")
  lastName    String    @map("last_name")
  callingName String?   @map("calling_name")
  addressId   String?   @unique @map("address_id")
  address     Address?  @relation(fields: [addressId], references: [id])
  // I don't think we need multiple phones per contact for now, so making it one-to-one
  // If payment and contact phone are not the same, we can store a different phone in paymentInformation on the recipient
  phoneId     String?   @map("phone_id")
  phone       Phone?    @relation(fields: [phoneId], references: [id])
  email       String?   @map("email")
  gender      Gender?   @map("gender")
  language    String?   @map("language")
  dateOfBirth DateTime? @map("date_of_birth") @db.Date
  profession  String?   @map("profession")

  contributor  Contributor?
  recipient    Recipient?
  localPartner LocalPartner?

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("contact")
}

model Phone {
  id                       String                   @id @default(cuid()) @map("id")
  // Instead of isPrimary flag. For recipients, mobile_money_phone could become "priamry", and mobile_money_phone "mobile_money" (which would also be attached to the paymentInformation of the recipient)
  type                     String                   @default("primary") @map("type")
  // We should store as strings and not as integers as we did so far
  number                   String                   @map("number")
  verified                 Boolean                  @default(false) @map("verified")
  whatsAppActivationStatus WhatsAppActivationStatus @default(disabled) @map("whats_app")
  contactId                String?
  PaymentInformation       PaymentInformation[]
  Contact                  Contact[]

  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(3)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  @@map("phone")
}

model ExchangeRate {
  id        String   @id @default(cuid()) @map("id")
  currency  String   @map("currency")
  rate      Decimal  @map("rate") @db.Decimal(10, 2)
  timestamp DateTime @map("timestamp") @db.Timestamptz(3)

  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(3)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(3)

  @@map("exchange_rate")
}
